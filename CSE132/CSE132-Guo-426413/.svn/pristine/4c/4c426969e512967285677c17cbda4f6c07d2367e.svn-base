package lab3a.model;
import java.beans.PropertyChangeSupport;
import java.util.HashSet;
import java.util.Set;

import lab3a.Lab;
import lab3a.locking.DoubleLock;
import lab3a.locking.SingleLockInvokable;

/** 
 * This is an abstract class, which means you cannot instantiate it. 
 * But it has two useful subclasses. Even though this class cannot be 
 * instantiated, you can still call methods on any Hall, as detailed below. 
 **/
abstract public class Hall {

	private PropertyChangeSupport pcs;
	private Room room1, room2;
	
	private Thread thread;

	public Hall(Room r1, Room r2) {
		pcs = new PropertyChangeSupport(this);
		this.room1 = r1;
		this.room2 = r2;
	}

	abstract public void openDoors();

	public PropertyChangeSupport getPCS() { return pcs; }

	/** Depends on whether we are horiz or vertical hall */
	abstract public SingleLockInvokable getLock1();
	/** Depends on whether we are horiz or vertical hall */
	abstract public SingleLockInvokable getLock2();

	/** Using an anonymous, inner class, spawn a new Thread that
	 * gets a {@link DoubleLock} on this hall's two rooms, and then
	 * calls openDoors (overridden in subclasses)
	 */
	public void attemptToConnectRooms() {
		thread = new Thread() {
			public void run() {
				DoubleLock dl = new DoubleLock(getLock1(), getLock2());
				dl.lockInvoke(
						new Runnable() {
							public void run() {
								// TODO: We should be more selective in when we connect rooms
								//
								// Change the sets so we can see the visualization respond to that
								// TODO: This all has to be changed to make the lab really work
								//
								// Do not be tempted to reuse either room's set for this union!
								// Make sure to create a new set, as you see below, add to that set,
								//   and then make that new set every room's set (last loop, below)
								//
								Set<Room> union = new HashSet<Room>();
								for (Room r : getRoom1().getSet()) {
									union.add(r);
								}
								for (Room r : getRoom2().getSet()) {
									union.add(r);
								}
								for (Room r : union) {
									r.setSet(union);
								}
								openDoors();
								Lab.sleep();
							}
						}
				);
			}
		};
		thread.start();
	}

	public Thread getThread() { return thread; } // FIX

	public String toString() {
		return("Hall between " + getRoom1() + " and " + getRoom2());
	}

	/** Returns the first room specified in the constructor call. **/
	public Room getRoom1() {
		return room1;
	}
	/** Returns the second room specified in the constructor call. **/
	public Room getRoom2() {
		return room2;
	}



}
